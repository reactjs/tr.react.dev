---
title: createRoot
---

<Intro>

`createRoot` React bileÅŸenlerini bir tarayÄ±cÄ± DOM dÃ¼ÄŸÃ¼mÃ¼ iÃ§inde gÃ¶rÃ¼ntÃ¼lemek iÃ§in bir kÃ¶k oluÅŸturmanÄ±zÄ± saÄŸlar.

```js
const root = createRoot(domNode, options?)
```

</Intro>

<InlineToc />

---

## Referans {/*reference*/}

### `createRoot(domNode, options?)` {/*createroot*/}

Ä°Ã§eriÄŸi bir tarayÄ±cÄ± DOM elemanÄ± iÃ§inde gÃ¶rÃ¼ntÃ¼lemek Ã¼zere bir React kÃ¶kÃ¼ oluÅŸturmak iÃ§in `createRoot` Ã§aÄŸrÄ±sÄ± yapÄ±n.

```js
import { createRoot } from 'react-dom/client';

const domNode = document.getElementById('root');
const root = createRoot(domNode);
```

React, `domNode` iÃ§in bir kÃ¶k oluÅŸturacak ve iÃ§indeki DOM'un yÃ¶netimini Ã¼stlenecek. Bir kÃ¶k oluÅŸturduktan sonra, iÃ§inde bir React bileÅŸeni gÃ¶rÃ¼ntÃ¼lemek iÃ§in [`root.render`](#root-render) Ã§aÄŸÄ±rmanÄ±z gerekir:

```js
root.render(<App />);
```

Tamamen React ile oluÅŸturulmuÅŸ bir uygulama genellikle kÃ¶k bileÅŸeni iÃ§in yalnÄ±zca bir `createRoot` Ã§aÄŸrÄ±sÄ±na sahip olacaktÄ±r. SayfanÄ±n bazÄ± bÃ¶lÃ¼mleri iÃ§in React "serpintileri" kullanan bir sayfa, ihtiyaÃ§ duyulan kadar Ã§ok sayÄ±da ayrÄ± kÃ¶ke sahip olabilir.

[Daha fazla Ã¶rnek iÃ§in aÅŸaÄŸÄ±ya bakÄ±n.](#usage)

#### Parametreler {/*parameters*/}

* `domNode`: Bir [DOM elemanÄ±.](https://developer.mozilla.org/en-US/docs/Web/API/Element) React bu DOM elemanÄ± iÃ§in bir kÃ¶k oluÅŸturacak ve `render` gibi render edilmiÅŸ React iÃ§eriÄŸini gÃ¶rÃ¼ntÃ¼lemek iÃ§in kÃ¶k Ã¼zerinde fonksiyonlar Ã§aÄŸÄ±rmanÄ±za izin verecektir.

* **opsiyonel** `options`: Bu React kÃ¶kÃ¼ iÃ§in seÃ§enekler iÃ§eren bir nesne.

<<<<<<< HEAD
  * <CanaryBadge title="Bu Ã¶zellik yalnÄ±zca Canary kanalÄ±nda mevcuttur" /> **opsiyonel** `onCaughtError`: React bir Hata yakalayÄ±cÄ± bir hata yakaladÄ±ÄŸÄ±nda callback yapÄ±lÄ±r. Hata yakalayÄ±cÄ± tarafÄ±ndan yakalanan `error` ve `componentStack` iÃ§eren bir `errorInfo` nesnesi ile Ã§aÄŸrÄ±lÄ±r.
  * <CanaryBadge title="This feature is only available in the Canary channel" /> **opsiyonel** Bir hata fÄ±rlatÄ±ldÄ±ÄŸÄ±nda ve bir Hata yakalayÄ±cÄ± tarafÄ±ndan yakalanmadÄ±ÄŸÄ±nda callback yapÄ±lÄ±r. AtÄ±lan hata ve `componentStack`'i iÃ§eren bir `errorInfo` nesnesi ile Ã§aÄŸrÄ±lÄ±r.
  * **opsiyonel** `onRecoverableError`: React'in hatalardan otomatik olarak kurtulduÄŸunda Ã§aÄŸrÄ±lan callback fonksiyonu. React'in attÄ±ÄŸÄ± bir `error` ve `componentStack` iÃ§eren bir `errorInfo` nesnesi ile Ã§aÄŸrÄ±lÄ±r. BazÄ± kurtarÄ±labilir hatalar, `error.cause` olarak orijinal hata nedenini iÃ§erebilir.
  * **opsiyonel** `identifierPrefix`: [`useId`](/reference/react/useId) tarafÄ±ndan oluÅŸturulan kimlikler iÃ§in React'in kullandÄ±ÄŸÄ± bir dize Ã¶neki. AynÄ± sayfada birden fazla kÃ¶k kullanÄ±rken Ã§akÄ±ÅŸmalarÄ± Ã¶nlemek iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.
=======
  * **optional** `onCaughtError`: Callback called when React catches an error in an Error Boundary. Called with the `error` caught by the Error Boundary, and an `errorInfo` object containing the `componentStack`.
  * **optional** `onUncaughtError`: Callback called when an error is thrown and not caught by an Error Boundary. Called with the `error` that was thrown, and an `errorInfo` object containing the `componentStack`.
  * **optional** `onRecoverableError`: Callback called when React automatically recovers from errors. Called with an `error` React throws, and an `errorInfo` object containing the `componentStack`. Some recoverable errors may include the original error cause as `error.cause`.
  * **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page.
>>>>>>> 9000e6e003854846c4ce5027703b5ce6f81aad80


#### DÃ¶ndÃ¼rÃ¼lenler {/*returns*/}

`createRoot` [`render`](#root-render) ve [`unmount`](#root-unmount) olmak Ã¼zere iki yÃ¶ntem iÃ§eren bir nesne dÃ¶ndÃ¼rÃ¼r.

#### UyarÄ±lar {/*caveats*/}
* UygulamanÄ±z sunucu tarafÄ±ndan oluÅŸturulmuÅŸsa, `createRoot()` kullanÄ±mÄ± desteklenmez. Bunun yerine [`hydrateRoot()`](/reference/react-dom/client/hydrateRoot) kullanÄ±n.
* UygulamanÄ±zda muhtemelen yalnÄ±zca bir `createRoot` Ã§aÄŸrÄ±sÄ± olacaktÄ±r. EÄŸer bir Ã§atÄ± kullanÄ±yorsanÄ±z, bu Ã§aÄŸrÄ±yÄ± sizin iÃ§in yapabilir.
* BileÅŸeninizin alt Ã¶ÄŸesi olmayan DOM aÄŸacÄ±nÄ±n farklÄ± bir bÃ¶lÃ¼mÃ¼nde bir JSX parÃ§asÄ± render etmek istediÄŸinizde (Ã¶rneÄŸin, bir modal veya bir araÃ§ ipucu), `createRoot` yerine [`createPortal`](/reference/react-dom/createPortal) kullanÄ±n.

---

### `root.render(reactNode)` {/*root-render*/}

React root'un tarayÄ±cÄ± DOM dÃ¼ÄŸÃ¼mÃ¼nde bir [JSX](/learn/writing-markup-with-jsx) parÃ§asÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in `root.render` Ã§aÄŸrÄ±sÄ± yapÄ±n.

```js
root.render(<App />);
```

React, `root` iÃ§inde `<App />` gÃ¶sterecek ve iÃ§indeki DOM'un yÃ¶netimini Ã¼stlenecektir.

[Daha fazla Ã¶rnek iÃ§in aÅŸaÄŸÄ±ya bakÄ±n.](#usage)

#### Parametreler {/*root-render-parameters*/}

* `reactNode`: GÃ¶rÃ¼ntÃ¼lemek istediÄŸiniz bir *React dÃ¼ÄŸÃ¼mÃ¼*. Bu genellikle `<App />` gibi bir JSX parÃ§asÄ± olacaktÄ±r, ancak [`createElement()`](/reference/react/createElement) ile oluÅŸturulmuÅŸ bir React elemanÄ±, bir string, bir sayÄ±, `null` veya `undefined` da iletebilirsiniz.


#### DÃ¶ndÃ¼rÃ¼lenler {/*root-render-returns*/}

`root.render` `undefined` deÄŸerini dÃ¶ndÃ¼rÃ¼r.

#### UyarÄ±lar {/*root-render-caveats*/}

* Ä°lk kez `root.render` fonksiyonunu Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ±z zaman React, React bileÅŸenini render etmeden Ã¶nce React kÃ¶kÃ¼ iÃ§indeki mevcut tÃ¼m HTML iÃ§eriÄŸini temizleyecektir.

* KÃ¶k DOM dÃ¼ÄŸÃ¼mÃ¼nÃ¼z sunucuda veya derleme sÄ±rasÄ±nda React tarafÄ±ndan oluÅŸturulan HTML iÃ§eriyorsa, bunun yerine olay iÅŸleyicilerini mevcut HTML'ye ekleyen [`hydrateRoot()`](/reference/react-dom/client/hydrateRoot) fonksiyonunu kullanÄ±n.

* AynÄ± kÃ¶k Ã¼zerinde birden fazla kez `render` Ã§aÄŸrÄ±sÄ± yaparsanÄ±z, React ilettiÄŸiniz en son JSX'i yansÄ±tmak iÃ§in DOM'u gerektiÄŸi gibi gÃ¼ncelleyecektir. React, DOM'un hangi bÃ¶lÃ¼mlerinin yeniden kullanÄ±labileceÄŸine ve hangilerinin yeniden oluÅŸturulmasÄ± gerektiÄŸine daha Ã¶nce oluÅŸturulmuÅŸ aÄŸaÃ§la ["eÅŸleÅŸtirerek"](/learn/preserving-and-resetting-state) daha Ã¶nce oluÅŸturulmuÅŸ aÄŸaÃ§la karar verecektir. AynÄ± kÃ¶k Ã¼zerinde `render` fonksiyonunu tekrar Ã§aÄŸÄ±rmak, kÃ¶k bileÅŸen Ã¼zerinde [`set` fonksiyonunu](/reference/react/useState#setstate) Ã§aÄŸÄ±rmaya benzer: React gereksiz DOM gÃ¼ncellemelerinden kaÃ§Ä±nÄ±r.

---

### `root.unmount()` {/*root-unmount*/}

React kÃ¶kÃ¼ iÃ§inde render edilmiÅŸ bir aÄŸacÄ± yok etmek iÃ§in `root.unmount` Ã§aÄŸÄ±rÄ±n.

```js
root.unmount();
```

Tamamen React ile oluÅŸturulan bir uygulamada genellikle `root.unmount` Ã§aÄŸrÄ±sÄ± olmayacaktÄ±r.

Bu, Ã§oÄŸunlukla React kÃ¶k DOM dÃ¼ÄŸÃ¼mÃ¼nÃ¼zÃ¼n (veya atalarÄ±ndan herhangi birinin) baÅŸka bir kod tarafÄ±ndan DOM'dan kaldÄ±rÄ±labileceÄŸi durumlarda kullanÄ±ÅŸlÄ±dÄ±r. Ã–rneÄŸin, etkin olmayan sekmeleri DOM'dan kaldÄ±ran bir jQuery sekme paneli dÃ¼ÅŸÃ¼nÃ¼n. Bir sekme kaldÄ±rÄ±lÄ±rsa, iÃ§indeki her ÅŸey (iÃ§indeki React kÃ¶kleri de dahil olmak Ã¼zere) DOM'dan da kaldÄ±rÄ±lacaktÄ±r. Bu durumda, React'e `root.unmount` Ã§aÄŸrÄ±sÄ± yaparak kaldÄ±rÄ±lan kÃ¶kÃ¼n iÃ§eriÄŸini yÃ¶netmeyi "durdurmasÄ±nÄ±" sÃ¶ylemeniz gerekir. Aksi takdirde, kaldÄ±rÄ±lan kÃ¶kÃ¼n iÃ§indeki bileÅŸenler, abonelikler gibi global kaynaklarÄ± temizlemeyi ve boÅŸaltmayÄ± bilemez.

`root.unmount` Ã§aÄŸrÄ±sÄ±, aÄŸaÃ§taki tÃ¼m olay yÃ¶neticilerini veya state'i kaldÄ±rmak da dahil olmak Ã¼zere, kÃ¶kteki tÃ¼m bileÅŸenleri DOM'dan kaldÄ±racak ve React'i kÃ¶k DOM dÃ¼ÄŸÃ¼mÃ¼nden "ayÄ±racaktÄ±r".


#### Parametreler {/*root-unmount-parameters*/}

`root.unmount` herhangi bir parametre kabul etmez.


#### DÃ¶ndÃ¼rÃ¼lenler {/*root-unmount-returns*/}

`root.unmount` `undefined` dÃ¶ndÃ¼rÃ¼r.

#### UyarÄ±lar {/*root-unmount-caveats*/}

* `root.unmount` Ã§aÄŸrÄ±sÄ±, aÄŸaÃ§taki tÃ¼m bileÅŸenleri DOM'dan kaldÄ±racak ve React'i kÃ¶k DOM dÃ¼ÄŸÃ¼mÃ¼nden "ayÄ±racaktÄ±r".

* Bir kez `root.unmount` Ã§aÄŸrÄ±sÄ± yaptÄ±ÄŸÄ±nÄ±zda, aynÄ± kÃ¶k Ã¼zerinde tekrar `root.render` Ã§aÄŸrÄ±sÄ± yapamazsÄ±nÄ±z. BaÄŸlanmamÄ±ÅŸ bir kÃ¶k Ã¼zerinde `root.render` Ã§aÄŸrÄ±lmaya Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nda "BaÄŸlanmamÄ±ÅŸ bir kÃ¶k gÃ¼ncellenemiyor" hatasÄ± verilir. Ancak, aynÄ± DOM dÃ¼ÄŸÃ¼mÃ¼ iÃ§in Ã¶nceki kÃ¶kÃ¼n baÄŸlantÄ±sÄ± kaldÄ±rÄ±ldÄ±ktan sonra yeni bir kÃ¶k oluÅŸturabilirsiniz.

---

## KullanÄ±m {/*usage*/}

### Tamamen React ile oluÅŸturulmuÅŸ bir uygulamayÄ± render etmek {/*rendering-an-app-fully-built-with-react*/}

EÄŸer uygulamanÄ±z tamamen React ile oluÅŸturulmuÅŸsa, uygulamanÄ±zÄ±n tamamÄ± iÃ§in tek bir kÃ¶k oluÅŸturun.

```js [[1, 3, "document.getElementById('root')"], [2, 4, "<App />"]]
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

Genellikle bu kodu baÅŸlangÄ±Ã§ta yalnÄ±zca bir kez Ã§alÄ±ÅŸtÄ±rmanÄ±z gerekir. Bu iÅŸlem ÅŸunlarÄ± yapacaktÄ±r:

1. HTML'nizde tanÄ±mlanan  <CodeStep step={1}>tarayÄ±cÄ± DOM</CodeStep> dÃ¼ÄŸÃ¼mÃ¼nÃ¼ bulun.
2. UygulamanÄ±zÄ±n  <CodeStep step={2}>React bileÅŸenini</CodeStep> iÃ§inde gÃ¶rÃ¼ntÃ¼leyin.

<Sandpack>

```html index.html
<!DOCTYPE html>
<html>
  <head><title>Benim uygulamam</title></head>
  <body>
    <!-- Bu DOM dÃ¼ÄŸÃ¼mÃ¼dÃ¼r -->
    <div id="root"></div>
  </body>
</html>
```

```js src/index.js active
import { createRoot } from 'react-dom/client';
import App from './App.js';
import './styles.css';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

```js src/App.js
import { useState } from 'react';

export default function App() {
  return (
    <>
      <h1>Merhaba DÃ¼nya!</h1>
      <Counter />
    </>
  );
}

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>
      Bana {count} kere tÄ±kladÄ±n 
    </button>
  );
}
```

</Sandpack>

**EÄŸer uygulamanÄ±z tamamen React ile oluÅŸturulmuÅŸsa, daha fazla kÃ¶k oluÅŸturmanÄ±z veya [`root.render`](#root-render)'Ä± tekrar Ã§aÄŸÄ±rmanÄ±z gerekmez.** 

Bu noktadan itibaren React tÃ¼m uygulamanÄ±zÄ±n DOM'unu yÃ¶netecektir. Daha fazla bileÅŸen eklemek iÃ§in, [bunlarÄ± `App` bileÅŸeninin iÃ§ine yerleÅŸtirin.](/learn/importing-and-exporting-components) KullanÄ±cÄ± arayÃ¼zÃ¼nÃ¼ gÃ¼ncellemeniz gerektiÄŸinde, bileÅŸenlerinizin her biri bunu [state kullanarak yapabilir.](/reference/react/useState) DOM dÃ¼ÄŸÃ¼mÃ¼nÃ¼n dÄ±ÅŸÄ±nda bir modal veya araÃ§ ipucu gibi ekstra iÃ§erik gÃ¶rÃ¼ntÃ¼lemeniz gerektiÄŸinde, [bunu bir portal ile oluÅŸturun.](/reference/react-dom/createPortal)

<Note>

HTML'niz boÅŸ olduÄŸunda, uygulamanÄ±n JavaScript kodu yÃ¼klenip Ã§alÄ±ÅŸana kadar kullanÄ±cÄ± boÅŸ bir sayfa gÃ¶rÃ¼r:

```html
<div id="root"></div>
```

Bu Ã§ok yavaÅŸ hissettirebilir! Bunu Ã§Ã¶zmek iÃ§in, bileÅŸenlerinizden [sunucuda veya derleme sÄ±rasÄ±nda] ilk HTML'yi oluÅŸturabilirsiniz. (/reference/react-dom/server) ArdÄ±ndan ziyaretÃ§ileriniz JavaScript kodunun herhangi biri yÃ¼klenmeden Ã¶nce metin okuyabilir, resimleri gÃ¶rebilir ve baÄŸlantÄ±lara tÄ±klayabilir. Bu optimizasyonu otomatik olarak yapan [bir framework kullanmanÄ±zÄ±](/learn/start-a-new-react-project#production-grade-react-frameworks) Ã¶neririz. Ne zaman Ã§alÄ±ÅŸtÄ±ÄŸÄ±na baÄŸlÄ± olarak buna *sunucu taraflÄ± render etme (SSR)* veya *statik site oluÅŸturma (SSG)* denir.

</Note>

<Pitfall>

**Sunucu taraflÄ± render veya statik oluÅŸturma kullanan uygulamalar `createRoot` yerine [`hydrateRoot`](/reference/react-dom/client/hydrateRoot) Ã§aÄŸÄ±rmalÄ±dÄ±r.** React daha sonra DOM dÃ¼ÄŸÃ¼mlerini HTML'nizden yok etmek ve yeniden oluÅŸturmak yerine *hydrate* edecektir (yeniden kullanacaktÄ±r).

</Pitfall>

---

### KÄ±smen React ile oluÅŸturulan bir sayfa render etmek {/*rendering-a-page-partially-built-with-react*/}

SayfanÄ±z [tamamen React ile oluÅŸturulmamÄ±ÅŸsa](/learn/add-react-to-an-existing-project#using-react-for-a-part-of-your-existing-page), React tarafÄ±ndan yÃ¶netilen her bir Ã¼st dÃ¼zey kullanÄ±cÄ± arayÃ¼zÃ¼ parÃ§asÄ± iÃ§in bir kÃ¶k oluÅŸturmak Ã¼zere `createRoot` Ã¶ÄŸesini birden Ã§ok kez Ã§aÄŸÄ±rabilirsiniz. Her kÃ¶kte [`root.render`](#root-render) Ã§aÄŸrÄ±sÄ± yaparak her kÃ¶kte farklÄ± iÃ§erikler gÃ¶rÃ¼ntÃ¼leyebilirsiniz.

Burada, index.html dosyasÄ±nda tanÄ±mlanan iki farklÄ± DOM dÃ¼ÄŸÃ¼mÃ¼ne iki farklÄ± React bileÅŸeni render edilmiÅŸtir:

<Sandpack>

```html public/index.html
<!DOCTYPE html>
<html>
  <head><title>Benim uygulamam</title></head>
  <body>
    <nav id="navigation"></nav>
    <main>
      <p>Bu paragraf React tarafÄ±ndan render edilmez (doÄŸrulamak iÃ§in index.html dosyasÄ±nÄ± aÃ§Ä±n).</p>
      <section id="comments"></section>
    </main>
  </body>
</html>
```

```js src/index.js active
import './styles.css';
import { createRoot } from 'react-dom/client';
import { Comments, Navigation } from './Components.js';

const navDomNode = document.getElementById('navigation');
const navRoot = createRoot(navDomNode); 
navRoot.render(<Navigation />);

const commentDomNode = document.getElementById('comments');
const commentRoot = createRoot(commentDomNode); 
commentRoot.render(<Comments />);
```

```js src/Components.js
export function Navigation() {
  return (
    <ul>
      <NavLink href="/">Ana Sayfa</NavLink>
      <NavLink href="/about">HakkÄ±nda</NavLink>
    </ul>
  );
}

function NavLink({ href, children }) {
  return (
    <li>
      <a href={href}>{children}</a>
    </li>
  );
}

export function Comments() {
  return (
    <>
      <h2>Yorumlar</h2>
      <Comment text="Merhaba!" author="Alper" />
      <Comment text="NasÄ±lsÄ±n?" author="ErdoÄŸan" />
    </>
  );
}

function Comment({ text, author }) {
  return (
    <p>{text} â€” <i>{author}</i></p>
  );
}
```

```css
nav ul { padding: 0; margin: 0; }
nav ul li { display: inline-block; margin-right: 20px; }
```

</Sandpack>

AyrÄ±ca [`document.createElement()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) ile yeni bir DOM dÃ¼ÄŸÃ¼mÃ¼ oluÅŸturabilir ve bunu dokÃ¼mana manuel olarak ekleyebilirsiniz.

```js
const domNode = document.createElement('div');
const root = createRoot(domNode);
root.render(<Comment />);
document.body.appendChild(domNode); // DokÃ¼manÄ±n herhangi bir yerine ekleyebilirsiniz
```

React aÄŸacÄ±nÄ± DOM dÃ¼ÄŸÃ¼mÃ¼nden kaldÄ±rmak ve onun tarafÄ±ndan kullanÄ±lan tÃ¼m kaynaklarÄ± temizlemek iÃ§in [`root.unmount`.](#root-unmount) Ã§aÄŸÄ±rÄ±n.

```js
root.unmount();
```

Bu, Ã§oÄŸunlukla React bileÅŸenleriniz farklÄ± bir Ã§atÄ±da yazÄ±lmÄ±ÅŸ bir uygulamanÄ±n iÃ§indeyse kullanÄ±ÅŸlÄ±dÄ±r.

---

### Bir kÃ¶k bileÅŸenin gÃ¼ncellenmesi {/*updating-a-root-component*/}

AynÄ± kÃ¶k Ã¼zerinde `render` fonksiyonunu birden fazla kez Ã§aÄŸÄ±rabilirsiniz. Ã–nceki render edilen ile bileÅŸen aÄŸaÃ§ yapÄ±sÄ± eÅŸleÅŸtiÄŸi sÃ¼rece, React [state'i koruyacaktÄ±r.](/learn/preserving-and-resetting-state). Bu Ã¶rnekte her saniyede tekrarlanan `render` Ã§aÄŸrÄ±larÄ±ndan kaynaklanan gÃ¼ncellemelerin yÄ±kÄ±cÄ± olmadÄ±ÄŸÄ±na dikkat edin. Ã–rneÄŸin girdi kutusuna yazÄ± yazÄ±yorsunuz:

<Sandpack>

```js src/index.js active
import { createRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = createRoot(document.getElementById('root'));

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);
```

```js src/App.js
export default function App({counter}) {
  return (
    <>
      <h1>Merhaba DÃ¼nya! {counter}</h1>
      <input placeholder="Buraya bir ÅŸeyler yazÄ±n" />
    </>
  );
}
```

</Sandpack>

Birden fazla kez `render` Ã§aÄŸrÄ±sÄ± yapmak nadirdir. Genellikle bileÅŸenleriniz bunun yerine [state gÃ¼ncellemesi](/reference/react/useState) yapacaktÄ±r.

### YakalanmamÄ±ÅŸ hatalar iÃ§in bir diyaloÄŸu gÃ¶sterme {/*show-a-dialog-for-uncaught-errors*/}

<<<<<<< HEAD
<Canary>

`onUncaughtError` sadece en son React Canary sÃ¼rÃ¼mÃ¼nde mevcuttur.

</Canary>

VarsayÄ±lan olarak, React tÃ¼m yakalanmamÄ±ÅŸ hatalarÄ± konsola kaydeder. Kendi hata raporlamanÄ±zÄ± uygulamak iÃ§in, isteÄŸe baÄŸlÄ± `onUncaughtError` root seÃ§eneÄŸini saÄŸlayabilirsin:
=======
By default, React will log all uncaught errors to the console. To implement your own error reporting, you can provide the optional `onUncaughtError` root option:
>>>>>>> 9000e6e003854846c4ce5027703b5ce6f81aad80

```js [[1, 6, "onUncaughtError"], [2, 6, "error", 1], [3, 6, "errorInfo"], [4, 10, "componentStack"]]
import { createRoot } from 'react-dom/client';

const root = createRoot(
  document.getElementById('root'),
  {
    onUncaughtError: (error, errorInfo) => {
      console.error(
        'YakalanmamÄ±ÅŸ hata',
        error,
        errorInfo.componentStack
      );
    }
  }
);
root.render(<App />);
```

<CodeStep step={1}>onUncaughtError</CodeStep> seÃ§eneÄŸi iki baÄŸÄ±msÄ±z deÄŸiÅŸkenle Ã§aÄŸrÄ±lan bir fonksiyondur:

1. FÄ±rlatÄ±lan <CodeStep step={2}>hata</CodeStep>.

2. HatanÄ±n <CodeStep step={4}>componentStack</CodeStep>'ini iÃ§eren bir <CodeStep step={3}>errorInfo</CodeStep> nesnesi.

Hata diyalog pencerelerini gÃ¶rÃ¼ntÃ¼lemek iÃ§in `onUncaughtError` kÃ¶k seÃ§eneÄŸini kullanabilirsin:

<Sandpack>

```html index.html hidden
<!DOCTYPE html>
<html>
<head>
  <title>Benim uygulamam</title>
</head>
<body>
<!--
  Error dialog in raw HTML
  since an error in the React app may crash.
-->
<div id="error-dialog" class="hidden">
  <h1 id="error-title" class="text-red"></h1>
  <h3>
    <pre id="error-message"></pre>
  </h3>
  <p>
    <pre id="error-body"></pre>
  </p>
  <h4 class="-mb-20">Meydana gelen hata:</h4>
  <pre id="error-component-stack" class="nowrap"></pre>
  <h4 class="mb-0">Ã‡aÄŸrÄ± yÄ±ÄŸÄ±nÄ±:</h4>
  <pre id="error-stack" class="nowrap"></pre>
  <div id="error-cause">
    <h4 class="mb-0">Sebep olan:</h4>
    <pre id="error-cause-message"></pre>
    <pre id="error-cause-stack" class="nowrap"></pre>
  </div>
  <button
    id="error-close"
    class="mb-10"
    onclick="document.getElementById('error-dialog').classList.add('hidden')"
  >
    Close
  </button>
  <h3 id="error-not-dismissible">Bu hata gÃ¶z ardÄ± edilemez.</h3>
</div>
<!-- This is the DOM node -->
<div id="root"></div>
</body>
</html>
```

```css src/styles.css active
label, button { display: block; margin-bottom: 20px; }
html, body { min-height: 300px; }

#error-dialog {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: white;
  padding: 15px;
  opacity: 0.9;
  text-wrap: wrap;
  overflow: scroll;
}

.text-red {
  color: red;
}

.-mb-20 {
  margin-bottom: -20px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-10 {
  margin-bottom: 10px;
}

pre {
  text-wrap: wrap;
}

pre.nowrap {
  text-wrap: nowrap;
}

.hidden {
 display: none;  
}
```

```js src/reportError.js hidden
function reportError({ title, error, componentStack, dismissable }) {
  const errorDialog = document.getElementById("error-dialog");
  const errorTitle = document.getElementById("error-title");
  const errorMessage = document.getElementById("error-message");
  const errorBody = document.getElementById("error-body");
  const errorComponentStack = document.getElementById("error-component-stack");
  const errorStack = document.getElementById("error-stack");
  const errorClose = document.getElementById("error-close");
  const errorCause = document.getElementById("error-cause");
  const errorCauseMessage = document.getElementById("error-cause-message");
  const errorCauseStack = document.getElementById("error-cause-stack");
  const errorNotDismissible = document.getElementById("error-not-dismissible");
  
  // Set the title
  errorTitle.innerText = title;
  
  // Display error message and body
  const [heading, body] = error.message.split(/\n(.*)/s);
  errorMessage.innerText = heading;
  if (body) {
    errorBody.innerText = body;
  } else {
    errorBody.innerText = '';
  }

  // Display component stack
  errorComponentStack.innerText = componentStack;

  // Display the call stack
  // Since we already displayed the message, strip it, and the first Error: line.
  errorStack.innerText = error.stack.replace(error.message, '').split(/\n(.*)/s)[1];
  
  // Display the cause, if available
  if (error.cause) {
    errorCauseMessage.innerText = error.cause.message;
    errorCauseStack.innerText = error.cause.stack;
    errorCause.classList.remove('hidden');
  } else {
    errorCause.classList.add('hidden');
  }
  // Display the close button, if dismissible
  if (dismissable) {
    errorNotDismissible.classList.add('hidden');
    errorClose.classList.remove("hidden");
  } else {
    errorNotDismissible.classList.remove('hidden');
    errorClose.classList.add("hidden");
  }
  
  // Show the dialog
  errorDialog.classList.remove("hidden");
}

export function reportCaughtError({error, cause, componentStack}) {
  reportError({ title: "Yakalanan Hata", error, componentStack,  dismissable: true});
}

export function reportUncaughtError({error, cause, componentStack}) {
  reportError({ title: "YakalanmamÄ±ÅŸ Hata", error, componentStack, dismissable: false });
}

export function reportRecoverableError({error, cause, componentStack}) {
  reportError({ title: "KurtarÄ±labilir Hata", error, componentStack,  dismissable: true });
}
```

```js src/index.js active
import { createRoot } from "react-dom/client";
import App from "./App.js";
import {reportUncaughtError} from "./reportError";
import "./styles.css";

const container = document.getElementById("root");
const root = createRoot(container, {
  onUncaughtError: (error, errorInfo) => {
    if (error.message !== 'Known error') {
      reportUncaughtError({
        error,
        componentStack: errorInfo.componentStack
      });
    }
  }
});
root.render(<App />);
```

```js src/App.js
import { useState } from 'react';

export default function App() {
  const [throwError, setThrowError] = useState(false);
  
  if (throwError) {
    foo.bar = 'baz';
  }
  
  return (
    <div>
      <span>Bu hata, hata diyaloÄŸunu gÃ¶sterir:</span>
      <button onClick={() => setThrowError(true)}>
        Hata fÄ±rlat
      </button>
    </div>
  );
}
```

</Sandpack>


### Hata yakalayÄ±cÄ± ile ilgili hatalarÄ± gÃ¶rÃ¼ntÃ¼leme {/*displaying-error-boundary-errors*/}

<<<<<<< HEAD
<Canary>

`onCaughtError` sadece en son React Canary sÃ¼rÃ¼mÃ¼nde mevcuttur.

</Canary>

VarsayÄ±lan olarak, React bir Hata yakalayÄ±cÄ± tarafÄ±ndan yakalanan tÃ¼m hatalarÄ± `console.error` dosyasÄ±na kaydeder. Bu davranÄ±ÅŸÄ± geÃ§ersiz kÄ±lmak iÃ§in, bir Hata yakalayÄ±cÄ± tarafÄ±ndan yakalanan hatalarÄ± iÅŸlemek Ã¼zere isteÄŸe baÄŸlÄ± `onCaughtError` kÃ¶k seÃ§eneÄŸini saÄŸlayabilirsin. [Hata yakalayÄ±cÄ±](/reference/react/Component#catching-rendering-errors-with-an-error-boundary):
=======
By default, React will log all errors caught by an Error Boundary to `console.error`. To override this behavior, you can provide the optional `onCaughtError` root option to handle errors caught by an [Error Boundary](/reference/react/Component#catching-rendering-errors-with-an-error-boundary):
>>>>>>> 9000e6e003854846c4ce5027703b5ce6f81aad80

```js [[1, 6, "onCaughtError"], [2, 6, "error", 1], [3, 6, "errorInfo"], [4, 10, "componentStack"]]
import { createRoot } from 'react-dom/client';

const root = createRoot(
  document.getElementById('root'),
  {
    onCaughtError: (error, errorInfo) => {
      console.error(
        'Yakalanan hata',
        error,
        errorInfo.componentStack
      );
    }
  }
);
root.render(<App />);
```

<CodeStep step={1}>onCaughtError</CodeStep> seÃ§eneÄŸi iki baÄŸÄ±msÄ±z deÄŸiÅŸkenle Ã§aÄŸrÄ±lan bir fonksiyondur:

1. Hata yakalayÄ±cÄ± tarafÄ±ndan yakalanan <CodeStep step={2}>hata</CodeStep>.
2. HatanÄ±n <CodeStep step={4}>componentStack</CodeStep>'ini iÃ§eren bir <CodeStep step={3}>errorInfo</CodeStep> nesnesi.

Hata diyologlarÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemek veya bilinen hatalarÄ± gÃ¼nlÃ¼kten filtrelemek iÃ§in `onCaughtError` kÃ¶k seÃ§eneÄŸini kullanabilirsin:

<Sandpack>

```html index.html hidden
<!DOCTYPE html>
<html>
<head>
  <title>Benim uygulamam</title>
</head>
<body>
<!--
  Error dialog in raw HTML
  since an error in the React app may crash.
-->
<div id="error-dialog" class="hidden">
  <h1 id="error-title" class="text-red"></h1>
  <h3>
    <pre id="error-message"></pre>
  </h3>
  <p>
    <pre id="error-body"></pre>
  </p>
  <h4 class="-mb-20">Meydana gelen hata:</h4>
  <pre id="error-component-stack" class="nowrap"></pre>
  <h4 class="mb-0">Ã‡aÄŸrÄ± yÄ±ÄŸÄ±nÄ±:</h4>
  <pre id="error-stack" class="nowrap"></pre>
  <div id="error-cause">
    <h4 class="mb-0">Sebep olan:</h4>
    <pre id="error-cause-message"></pre>
    <pre id="error-cause-stack" class="nowrap"></pre>
  </div>
  <button
    id="error-close"
    class="mb-10"
    onclick="document.getElementById('error-dialog').classList.add('hidden')"
  >
    Close
  </button>
  <h3 id="error-not-dismissible">Bu hata gÃ¶z ardÄ± edilemez.</h3>
</div>
<!-- This is the DOM node -->
<div id="root"></div>
</body>
</html>
```

```css src/styles.css active
label, button { display: block; margin-bottom: 20px; }
html, body { min-height: 300px; }

#error-dialog {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: white;
  padding: 15px;
  opacity: 0.9;
  text-wrap: wrap;
  overflow: scroll;
}

.text-red {
  color: red;
}

.-mb-20 {
  margin-bottom: -20px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-10 {
  margin-bottom: 10px;
}

pre {
  text-wrap: wrap;
}

pre.nowrap {
  text-wrap: nowrap;
}

.hidden {
 display: none;  
}
```

```js src/reportError.js hidden
function reportError({ title, error, componentStack, dismissable }) {
  const errorDialog = document.getElementById("error-dialog");
  const errorTitle = document.getElementById("error-title");
  const errorMessage = document.getElementById("error-message");
  const errorBody = document.getElementById("error-body");
  const errorComponentStack = document.getElementById("error-component-stack");
  const errorStack = document.getElementById("error-stack");
  const errorClose = document.getElementById("error-close");
  const errorCause = document.getElementById("error-cause");
  const errorCauseMessage = document.getElementById("error-cause-message");
  const errorCauseStack = document.getElementById("error-cause-stack");
  const errorNotDismissible = document.getElementById("error-not-dismissible");

  // Set the title
  errorTitle.innerText = title;

  // Display error message and body
  const [heading, body] = error.message.split(/\n(.*)/s);
  errorMessage.innerText = heading;
  if (body) {
    errorBody.innerText = body;
  } else {
    errorBody.innerText = '';
  }

  // Display component stack
  errorComponentStack.innerText = componentStack;

  // Display the call stack
  // Since we already displayed the message, strip it, and the first Error: line.
  errorStack.innerText = error.stack.replace(error.message, '').split(/\n(.*)/s)[1];

  // Display the cause, if available
  if (error.cause) {
    errorCauseMessage.innerText = error.cause.message;
    errorCauseStack.innerText = error.cause.stack;
    errorCause.classList.remove('hidden');
  } else {
    errorCause.classList.add('hidden');
  }
  // Display the close button, if dismissible
  if (dismissable) {
    errorNotDismissible.classList.add('hidden');
    errorClose.classList.remove("hidden");
  } else {
    errorNotDismissible.classList.remove('hidden');
    errorClose.classList.add("hidden");
  }

  // Show the dialog
  errorDialog.classList.remove("hidden");
}

export function reportCaughtError({error, cause, componentStack}) {
  reportError({ title: "Yakalanan Hata", error, componentStack,  dismissable: true});
}

export function reportUncaughtError({error, cause, componentStack}) {
  reportError({ title: "YakalanmamÄ±ÅŸ Hata", error, componentStack, dismissable: false });
}

export function reportRecoverableError({error, cause, componentStack}) {
  reportError({ title: "KurtarÄ±labilir Hata", error, componentStack,  dismissable: true });
}
```

```js src/index.js active
import { createRoot } from "react-dom/client";
import App from "./App.js";
import {reportCaughtError} from "./reportError";
import "./styles.css";

const container = document.getElementById("root");
const root = createRoot(container, {
  onCaughtError: (error, errorInfo) => {
    if (error.message !== 'Known error') {
      reportCaughtError({
        error, 
        componentStack: errorInfo.componentStack,
      });
    }
  }
});
root.render(<App />);
```

```js src/App.js
import { useState } from 'react';
import { ErrorBoundary } from "react-error-boundary";

export default function App() {
  const [error, setError] = useState(null);
  
  function handleUnknown() {
    setError("unknown");
  }

  function handleKnown() {
    setError("known");
  }
  
  return (
    <>
      <ErrorBoundary
        fallbackRender={fallbackRender}
        onReset={(details) => {
          setError(null);
        }}
      >
        {error != null && <Throw error={error} />}
        <span>Bu hata, hata diyaloÄŸunu gÃ¶stermeyecektir:</span>
        <button onClick={handleKnown}>
          Bilinen hatayÄ± fÄ±rlat
        </button>
        <span>Bu hata, hata diyoloÄŸunu gÃ¶sterecektir:</span>
        <button onClick={handleUnknown}>
          Bilinmeyen bir hata fÄ±rlat
        </button>
      </ErrorBoundary>
      
    </>
  );
}

function fallbackRender({ resetErrorBoundary }) {
  return (
    <div role="alert">
      <h3>Hata YakalayÄ±cÄ±</h3>
      <p>Bir ÅŸeyler ters gitti.</p>
      <button onClick={resetErrorBoundary}>SÄ±fÄ±rla</button>
    </div>
  );
}

function Throw({error}) {
  if (error === "known") {
    throw new Error('Known error')
  } else {
    foo.bar = 'baz';
  }
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "19.0.0-rc-3edc000d-20240926",
    "react-dom": "19.0.0-rc-3edc000d-20240926",
    "react-scripts": "^5.0.0",
    "react-error-boundary": "4.0.3"
  },
  "main": "/index.js"
}
```

</Sandpack>

### KurtarÄ±labilir hatalar iÃ§in bir diyoloÄŸu gÃ¶rÃ¼ntÃ¼leme {/*displaying-a-dialog-for-recoverable-errors*/}

React, render etme sÄ±rasÄ±nda atÄ±lan bir hatadan kurtulmayÄ± denemek iÃ§in bir bileÅŸeni otomatik olarak ikinci kez render edebilir. BaÅŸarÄ±lÄ± olursa, React geliÅŸtiriciyi bilgilendirmek iÃ§in konsola kurtarÄ±labilir bir hata gÃ¼nlÃ¼ÄŸÃ¼ kaydeder. Bu davranÄ±ÅŸÄ± geÃ§ersiz kÄ±lmak iÃ§in, isteÄŸe baÄŸlÄ± `onRecoverableError` kÃ¶k seÃ§eneÄŸini saÄŸlayabilirsin:

```js [[1, 6, "onRecoverableError"], [2, 6, "error", 1], [3, 10, "error.cause"], [4, 6, "errorInfo"], [5, 11, "componentStack"]]
import { createRoot } from 'react-dom/client';

const root = createRoot(
  document.getElementById('root'),
  {
    onRecoverableError: (error, errorInfo) => {
      console.error(
        'KurtarÄ±labilir hata',
        error,
        error.cause,
        errorInfo.componentStack,
      );
    }
  }
);
root.render(<App />);
```

<CodeStep step={1}>onRecoverableError</CodeStep> seÃ§eneÄŸi iki baÄŸÄ±msÄ±z deÄŸiÅŸkenle Ã§aÄŸrÄ±lan bir fonksiyondur:

1. React'in fÄ±rlattÄ±ÄŸÄ± <CodeStep step={2}>hata</CodeStep>. BazÄ± hatalar, <CodeStep step={3}>error.cause</CodeStep> olarak orijinal nedeni iÃ§erebilir.

2. HatanÄ±n <CodeStep step={5}>componentStack</CodeStep>'ini iÃ§eren bir <CodeStep step={4}>errorInfo</CodeStep> nesnesi.

Hata diyaloglarÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in `onRecoverableError` kÃ¶k seÃ§eneÄŸini kullanabilirsin:

<Sandpack>

```html index.html hidden
<!DOCTYPE html>
<html>
<head>
  <title>Benim uygulamam</title>
</head>
<body>
<!--
  Error dialog in raw HTML
  since an error in the React app may crash.
-->
<div id="error-dialog" class="hidden">
  <h1 id="error-title" class="text-red"></h1>
  <h3>
    <pre id="error-message"></pre>
  </h3>
  <p>
    <pre id="error-body"></pre>
  </p>
  <h4 class="-mb-20">Meydana gelen hata:</h4>
  <pre id="error-component-stack" class="nowrap"></pre>
  <h4 class="mb-0">Ã‡aÄŸrÄ± yÄ±ÄŸÄ±nÄ±:</h4>
  <pre id="error-stack" class="nowrap"></pre>
  <div id="error-cause">
    <h4 class="mb-0">Sebep olan:</h4>
    <pre id="error-cause-message"></pre>
    <pre id="error-cause-stack" class="nowrap"></pre>
  </div>
  <button
    id="error-close"
    class="mb-10"
    onclick="document.getElementById('error-dialog').classList.add('hidden')"
  >
    Close
  </button>
  <h3 id="error-not-dismissible">Bu hata gÃ¶z ardÄ± edilemez.</h3>
</div>
<!-- This is the DOM node -->
<div id="root"></div>
</body>
</html>
```

```css src/styles.css active
label, button { display: block; margin-bottom: 20px; }
html, body { min-height: 300px; }

#error-dialog {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: white;
  padding: 15px;
  opacity: 0.9;
  text-wrap: wrap;
  overflow: scroll;
}

.text-red {
  color: red;
}

.-mb-20 {
  margin-bottom: -20px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-10 {
  margin-bottom: 10px;
}

pre {
  text-wrap: wrap;
}

pre.nowrap {
  text-wrap: nowrap;
}

.hidden {
 display: none;  
}
```

```js src/reportError.js hidden
function reportError({ title, error, componentStack, dismissable }) {
  const errorDialog = document.getElementById("error-dialog");
  const errorTitle = document.getElementById("error-title");
  const errorMessage = document.getElementById("error-message");
  const errorBody = document.getElementById("error-body");
  const errorComponentStack = document.getElementById("error-component-stack");
  const errorStack = document.getElementById("error-stack");
  const errorClose = document.getElementById("error-close");
  const errorCause = document.getElementById("error-cause");
  const errorCauseMessage = document.getElementById("error-cause-message");
  const errorCauseStack = document.getElementById("error-cause-stack");
  const errorNotDismissible = document.getElementById("error-not-dismissible");

  // Set the title
  errorTitle.innerText = title;

  // Display error message and body
  const [heading, body] = error.message.split(/\n(.*)/s);
  errorMessage.innerText = heading;
  if (body) {
    errorBody.innerText = body;
  } else {
    errorBody.innerText = '';
  }

  // Display component stack
  errorComponentStack.innerText = componentStack;

  // Display the call stack
  // Since we already displayed the message, strip it, and the first Error: line.
  errorStack.innerText = error.stack.replace(error.message, '').split(/\n(.*)/s)[1];

  // Display the cause, if available
  if (error.cause) {
    errorCauseMessage.innerText = error.cause.message;
    errorCauseStack.innerText = error.cause.stack;
    errorCause.classList.remove('hidden');
  } else {
    errorCause.classList.add('hidden');
  }
  // Display the close button, if dismissible
  if (dismissable) {
    errorNotDismissible.classList.add('hidden');
    errorClose.classList.remove("hidden");
  } else {
    errorNotDismissible.classList.remove('hidden');
    errorClose.classList.add("hidden");
  }

  // Show the dialog
  errorDialog.classList.remove("hidden");
}

export function reportCaughtError({error, cause, componentStack}) {
  reportError({ title: "Yakalanan Hata", error, componentStack,  dismissable: true});
}

export function reportUncaughtError({error, cause, componentStack}) {
  reportError({ title: "YakalanmamÄ±ÅŸ Hata", error, componentStack, dismissable: false });
}

export function reportRecoverableError({error, cause, componentStack}) {
  reportError({ title: "KurtarÄ±labilir Hata", error, componentStack,  dismissable: true });
}
```

```js src/index.js active
import { createRoot } from "react-dom/client";
import App from "./App.js";
import {reportRecoverableError} from "./reportError";
import "./styles.css";

const container = document.getElementById("root");
const root = createRoot(container, {
  onRecoverableError: (error, errorInfo) => {
    reportRecoverableError({
      error,
      cause: error.cause,
      componentStack: errorInfo.componentStack,
    });
  }
});
root.render(<App />);
```

```js src/App.js
import { useState } from 'react';
import { ErrorBoundary } from "react-error-boundary";

// ğŸš© Bug: Never do this. This will force an error.
let errorThrown = false;
export default function App() {
  return (
    <>
      <ErrorBoundary
        fallbackRender={fallbackRender}
      >
        {!errorThrown && <Throw />}
        <p>Bu bileÅŸen bir hata fÄ±rlattÄ±, ancak ikinci bir render etme sÄ±rasÄ±nda dÃ¼zeldi.</p>
        <p>KurtarÄ±ldÄ±ÄŸÄ± iÃ§in Hata yakalayÄ±cÄ± gÃ¶sterilmedi, ancak bir hata diyoloÄŸu gÃ¶stermek iÃ§in <code>onRecoverableError</code> kullanÄ±ldÄ±.</p>
      </ErrorBoundary>
      
    </>
  );
}

function fallbackRender() {
  return (
    <div role="alert">
      <h3>Hata YakalayÄ±cÄ±</h3>
      <p>Bir ÅŸeyler ters gitti.</p>
    </div>
  );
}

function Throw({error}) {
  // Simulate an external value changing during concurrent render.
  errorThrown = true;
  foo.bar = 'baz';
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "19.0.0-rc-3edc000d-20240926",
    "react-dom": "19.0.0-rc-3edc000d-20240926",
    "react-scripts": "^5.0.0",
    "react-error-boundary": "4.0.3"
  },
  "main": "/index.js"
}
```

</Sandpack>


---
## Sorun Giderme {/*troubleshooting*/}

### Bir kÃ¶k oluÅŸturdum, fakat hiÃ§bir ÅŸey gÃ¶rÃ¼ntÃ¼lenmiyor. {/*ive-created-a-root-but-nothing-is-displayed*/}

UygulamanÄ±zÄ± kÃ¶k iÃ§ine gerÃ§ekten render etmeyi unutmadÄ±ÄŸÄ±nÄ±zdan emin olun:

```js {5}
import { createRoot } from 'react-dom/client';
import App from './App.js';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

Bunu yapana kadar hiÃ§bir ÅŸey gÃ¶rÃ¼ntÃ¼lenmez.

---

### Bir hata alÄ±yorum: "root.render'a ikinci bir argÃ¼man geÃ§tiniz" {/*im-getting-an-error-you-passed-a-second-argument-to-root-render*/}

SÄ±k yapÄ±lan bir hata, `createRoot` seÃ§eneklerini `root.render(...)` Ã¶ÄŸesine aktarmaktÄ±r:

<ConsoleBlock level="error">

UyarÄ±: root.render(...) Ã¶ÄŸesine ikinci bir baÄŸÄ±msÄ±z deÄŸiÅŸken ilettiniz, ancak bu Ã¶ÄŸe yalnÄ±zca bir baÄŸÄ±msÄ±z deÄŸiÅŸken kabul eder.

</ConsoleBlock>

DÃ¼zeltmek iÃ§in, kÃ¶k seÃ§eneklerini `root.render(...)` yerine `createRoot(...)` Ã¶ÄŸesine aktarÄ±n:
```js {2,5}
// ğŸš© Wrong: root.render only takes one argument.
root.render(App, {onUncaughtError});

// âœ… Correct: pass options to createRoot.
const root = createRoot(container, {onUncaughtError}); 
root.render(<App />);
```

---

### Bir hata alÄ±yorum: "Hedef kapsayÄ±cÄ± bir DOM Ã¶ÄŸesi deÄŸil" {/*im-getting-an-error-target-container-is-not-a-dom-element*/}

Bu hata, `createRoot` Ã¶ÄŸesine aktardÄ±ÄŸÄ±nÄ±z ÅŸeyin bir DOM dÃ¼ÄŸÃ¼mÃ¼ olmadÄ±ÄŸÄ± anlamÄ±na gelir.

Ne olduÄŸundan emin deÄŸilseniz, yazdÄ±rmayÄ±(log) deneyin:

```js {2}
const domNode = document.getElementById('root');
console.log(domNode); // ???
const root = createRoot(domNode);
root.render(<App />);
```

Ã–rneÄŸin, `domNode` `null` ise, [`getElementById`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById) `null` dÃ¶ndÃ¼rmÃ¼ÅŸ demektir. Bu, Ã§aÄŸrÄ±nÄ±z sÄ±rasÄ±nda dokÃ¼manda verilen kimliÄŸe sahip bir dÃ¼ÄŸÃ¼m yoksa gerÃ§ekleÅŸir. Bunun birkaÃ§ nedeni olabilir:

1. AradÄ±ÄŸÄ±nÄ±z ID, HTML dosyasÄ±nda kullandÄ±ÄŸÄ±nÄ±z ID'den farklÄ± olabilir. YazÄ±m hatalarÄ±nÄ± kontrol edin!
2. Paketinizin `<script>` etiketi, HTML'de kendisinden *sonra* gÃ¶rÃ¼nen herhangi bir DOM dÃ¼ÄŸÃ¼mÃ¼nÃ¼ "gÃ¶remez".

Bu hatayÄ± almanÄ±n bir baÅŸka yaygÄ±n yolu da `createRoot(domNode)` yerine `createRoot(<App />)` yazmaktÄ±r.

---

### Bir hata alÄ±yorum: "Fonksiyonlar bir React alt elemanÄ± olarak geÃ§erli deÄŸildir." {/*im-getting-an-error-functions-are-not-valid-as-a-react-child*/}

Bu hata, `root.render`a aktardÄ±ÄŸÄ±nÄ±z ÅŸeyin bir React bileÅŸeni olmadÄ±ÄŸÄ± anlamÄ±na gelir.

Bu, `root.render` Ã¶ÄŸesini `<Component />` yerine `Component` ile Ã§aÄŸÄ±rÄ±rsanÄ±z meydana gelebilir:

```js {2,5}
// ğŸš© YanlÄ±ÅŸ: App bir fonksiyondur, BileÅŸen deÄŸildir.
root.render(App);

// âœ… DoÄŸru: <App /> bir bileÅŸendir.
root.render(<App />);
```

Veya `root.render`'a fonksiyonu Ã§aÄŸÄ±rmanÄ±n sonucu yerine fonksiyonun kendisini iletirseniz:

```js {2,5}
// ğŸš© YanlÄ±ÅŸ: createApp bir fonksiyondur, bileÅŸen deÄŸildir.
root.render(createApp);

// âœ… DoÄŸru: Bir bileÅŸen dÃ¶ndÃ¼rmek iÃ§in createApp'i Ã§aÄŸÄ±rÄ±n.
root.render(createApp());
```

---

### Sunucu tarafÄ±ndan render edilen HTML'im sÄ±fÄ±rdan yeniden oluÅŸturuluyor {/*my-server-rendered-html-gets-re-created-from-scratch*/}

UygulamanÄ±z sunucu tarafÄ±ndan render ediliyorsa ve React tarafÄ±ndan oluÅŸturulan ilk HTML'yi iÃ§eriyorsa, bir kÃ¶k oluÅŸturmanÄ±n ve `root.render` Ã§aÄŸrÄ±sÄ±nÄ±n tÃ¼m bu HTML'yi sildiÄŸini ve ardÄ±ndan tÃ¼m DOM dÃ¼ÄŸÃ¼mlerini sÄ±fÄ±rdan yeniden oluÅŸturduÄŸunu fark edebilirsiniz. Bu daha yavaÅŸ olabilir, odak ve kaydÄ±rma konumlarÄ±nÄ± sÄ±fÄ±rlayabilir ve diÄŸer kullanÄ±cÄ± girdilerini kaybedebilir.

Sunucu tarafÄ±ndan render edilen uygulamalar `createRoot` yerine [`hydrateRoot`](/reference/react-dom/client/hydrateRoot) kullanmalÄ±dÄ±r:

```js {1,4-7}
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(
  document.getElementById('root'),
  <App />
);
```

API'sinin farklÄ± olduÄŸunu unutmayÄ±n. Ã–zellikle, baÅŸka bir `root.render` Ã§aÄŸrÄ±sÄ± genellikle gerÃ§ekleÅŸmeyecektir.